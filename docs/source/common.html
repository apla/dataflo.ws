<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var util = require ('util');

if (!util.inherits) {
	util.inherits = function (ctor, superCtor) {
		ctor.super_ = superCtor;
		ctor.prototype = Object.create (superCtor.prototype, {
			constructor: {
			value: ctor,
			enumerable: false,
			writable: true,
			configurable: true
		}});
	};
}

if (!util.extend) {
util.extend = function extend () {
	// copy reference to target object
	var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy;
	// Handle a deep copy situation
	if (typeof target === &quot;boolean&quot;) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	// Handle case when target is a string or something (possible in deep copy)
	if (typeof target !== &quot;object&quot; &amp;&amp; !typeof target === 'function')
		target = {};
	var isPlainObject = function(obj) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if (!obj || toString.call(obj) !== &quot;[object Object]&quot; || obj.nodeType || obj.setInterval)
			return false;
		var has_own_constructor = hasOwnProperty.call(obj, &quot;constructor&quot;);
		var has_is_property_of_method = hasOwnProperty.call(obj.constructor.prototype, &quot;isPrototypeOf&quot;);
		// Not own constructor property must be Object
		if (obj.constructor &amp;&amp; !has_own_constructor &amp;&amp; !has_is_property_of_method)
			return false;
		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var last_key;
		for (key in obj)
			last_key = key;
		return typeof last_key === &quot;undefined&quot; || hasOwnProperty.call(obj, last_key);
	};
	for (; i &lt; length; i++) {
		// Only deal with non-null/undefined values
		if ((options = arguments[i]) !== null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];
				// Prevent never-ending loop
				if (target === copy)
					continue;
				// Recurse if we're merging object literal values or arrays
				if (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || Array.isArray(copy))) {
					var clone = src &amp;&amp; (isPlainObject(src) || Array.isArray(src)) ? src : Array.isArray(copy) ? [] : {};
					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);
					// Don't bring in undefined values
				} else if (typeof copy !== &quot;undefined&quot;)
					target[name] = copy;
			}
		}
	}
	// Return the modified object
	return target;
}
}

try {
	if (process.pid) {
		global.$isClientSide = false;
		global.$isServerSide = true;
		global.$mainModule   = process.mainModule.exports;
		global.$scope        = 'process.mainModule.exports';
		global.$stash        = {};
		global.$isPhoneGap   = false;
	} else {
		throw 'WTF?';
	}
} catch (e) {
	window.$isClientSide = true;
	window.$isServerSide = false;
	window.$mainModule   = window;
	window.$scope        = 'window';
	window.$stash        = {};
	try {
		if (PhoneGap) window.$isPhoneGap = true;
	} catch (e) {
		window.$isPhoneGap = false;
	}
}

Number.prototype.hours = Number.prototype.hour
	= function () {return this * 60 * 60 * 1e3}
Number.prototype.minutes = Number.prototype.minute
	= function () {return this * 60 * 1e3}
Number.prototype.seconds = Number.prototype.second
	= function () {return this * 1e3}

Number.prototype.times = function (cb) {
	var a = [];
	for (var i = 0; i &lt; this; i++)
		a[i] = cb (i);
	return a;
}

var pathToVal = module.exports.pathToVal = function (dict, path, value) {
//	console.log ('pathToVal ('+ dict + ', '+ path + ', '+value+')');
	var chunks = path.split ('.');
	if (chunks.length == 1) {
		var oldValue = dict[chunks[0]];
		if (value !== void(0))
			dict[chunks[0]] = value;
//		console.log (''+oldValue);
		return oldValue;
	}
	return pathToVal (dict[chunks.shift()], chunks.join('.'), value)
}


var findInterpolation = module.exports.findInterpolation = function (params, prefix) {
	
	// parse task params
	// TODO: modify this function because recursive changes of parameters works dirty (indexOf for value)
	
	if (prefix == void 0) prefix = '';
	if (prefix) prefix += '.';
	
	var found = {};
	
	if (params.constructor == Array) { // params is array
		
		params.forEach(function (val, index, arr) {
			
			if (val.indexOf &amp;&amp; val.interpolate) { // string				
				
				var tmp = val.interpolate ({}, false, true);
				
				if (tmp !== void 0) {
					found[prefix + index] = tmp;
				}

			} else if (!val.toFixed) { // array and object (check for function and boolean)
				var result = findInterpolation (val, prefix+index);
				for (var attrname in result) {
					found[attrname] = result[attrname];
				}
			}
		});
		
	} else { // params is hash
	
		modifiedParams = {};
		
		for (var key in params) {
			var val = params[key];

			if (val.indexOf &amp;&amp; val.interpolate) { // string				
				
				var tmp = val.interpolate ({}, false, true);
				
				if (tmp !== void 0) {
					found[prefix + key] = tmp;
				}

			} else if (!val.toFixed) { // array and object (check for function and boolean)
				var result = findInterpolation (val, prefix+key);
				for (var attrname in result) {
					found[attrname] = result[attrname];
				}
			}
		}
	}
	
	return found;
}

var define;
if (typeof define === &quot;undefined&quot;)
	define = function () {}

define (function (require, exports, module) {
	return {
		pathToVal: pathToVal,
		findInterpolation: findInterpolation
	};
});


String.prototype.interpolate = function (dict, marks, checkOnly) {
	if (!marks)
		marks = {
			start: '{$', end: '}', path: '.'
		};
	
	var result;
	
	var interpolatePaths = [];
	
	var template = this;
	
	var pos = this.indexOf (marks.start);
	while (pos &gt; -1) {
		var end = (result || this).indexOf (marks.end, pos);
		var str = (result || this).substr (pos + 2, end - pos - 2);
		
		if (checkOnly &amp;&amp; str) {
			interpolatePaths.push (str);
			pos = this.indexOf (marks.start, end);
			continue;
		}
		
//		console.log (&quot;found replacement: key =&gt; ???, requires =&gt; $&quot;+this+&quot;\n&quot;);
		
		var fix;
		if (str.indexOf (marks.path) &gt; -1) { //  treat as path
			fix = pathToVal (dict, str);
		} else { // scalar
			fix = dict[str];
		}
		
		if (fix === void(0))
			throw (result || this);
		
		if (fix.indexOf &amp;&amp; fix.indexOf (marks.start) &gt; -1)
			throw 'interpolation mark &quot;' + marks.start + '&quot; within interpolation string (' + fix + ') is denied';
		
		if (pos == 0 &amp;&amp; end == ((result || this).length - 1)) {
			result = fix;
		} else {
			result = (result || this).substr (0, pos) + fix + (result || this).substr (end + 1);
//			console.log ('!!!', (result || this).toString(), fix.toString(), pos, end, end - pos + 1);
		}
		
		if ((((result === false || result === 0 || result === &quot;&quot;) ? true : result) || this).indexOf)
			pos = (((result === false || result === 0 || result === &quot;&quot;) ? true : result) || this).indexOf (marks.start);
		else
			break;
	}
	
	if (checkOnly)
		return interpolatePaths;
	
	return result;

};

if ($isServerSide) {

	var path = require ('path');

	var io = require ('./io/easy');

	var project = function () {
		// TODO: root directory object
		var script = process.argv[1];
		var rootPath = script.match (/(.*)\/(bin|t|lib)\//);
		
		if (!rootPath) {//win
			rootPath = script.match (/(.*)\\(bin|t|lib)\\/)
		}
		
		if (!rootPath)
			return;
		
		var root = new io (rootPath[1]);
		
		this.root = root;
		var self = this;
		
		root.fileIO ('etc/project').readFile (function (err, data) {
			if (err) {
				console.error (&quot;can't access etc/project file. create one and define project id&quot;);
				// process.kill ();
				return;
			}
			
			var configData = (&quot;&quot;+data).match (/(\w+)(\W[^]*)/);
			configData.shift ();
			var parser = configData.shift ();

			// console.log ('parsing etc/project using &quot;' + parser + '&quot; parser');
			
			if (parser == 'json') {

				try {
					var config = JSON.parse (configData[0]);
				} catch (e) {
					console.log ('WARNING: http config cannon parsed');
					throw e;
				}
				
				self.id     = config.id;
				self.config = config;
				
				
				// TODO: read config fixup
			} else {
				console.error ('parser ' + parser + ' unknown');
				// process.kill ();
				return;
			}


			root.fileIO ('var/instance').readFile (function (err, data) {
				
				if (err) {
					console.error (&quot;PROBABLY HARMFUL: can't access var/instance: &quot;+err);
					self.emit ('ready');
					return;
				}
				
				var instance = (&quot;&quot;+data).split (/\n/)[0];
				
				self.instance = instance;
				
				console.log ('instance is: ', instance);
			
				root.fileIO ('etc/' + instance + '/fixup').readFile (function (err, data) {
					if (err) {
						console.error (&quot;PROBABLY HARMFUL: can't access &quot;+'etc/' + instance + '/fixup'+&quot; file. &quot;
							+ &quot;create one and define local configuration fixup. &quot;
						);
						self.emit ('ready');
						// process.kill ();
						return;
						
					}
					
					var fixupData = (&quot;&quot;+data).match (/(\w+)(\W[^]*)/);
					fixupData.shift ();
					var fixupParser = fixupData.shift ();

					var fixupData = (&quot;&quot;+data).match (/(\w+)(\W[^]*)/);
					fixupData.shift ();
					var fixupParser = fixupData.shift ();

					// console.log ('parsing etc/' + instance + '/fixup using &quot;' + fixupParser + '&quot; parser');
					// TODO: error handling

					if (fixupParser == 'json') {
						var config = JSON.parse (configData[0]);
						
						util.extend (true, self.config, config);
					} else {
						console.log ('parser ' + fixupParser + ' unknown');
						// process.kill ();
						return;
					}
					
					console.log ('project ready');
					
					self.emit ('ready');
				});
			});
		});
		
		// TODO: walk filetree to find directory root if script located in
		// subdir of bin or t
	//	console.log (root);
		
	}

	var EventEmitter = require ('events').EventEmitter;

	util.inherits (project, EventEmitter);

	util.extend (project.prototype, {
		connectors:  {},
		connections: {}
	});

	global.project = new project ();

}
</pre>
</body>
</html>
