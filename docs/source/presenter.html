<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var task         = require ('task/base'),
	util         = require ('util');

try {
	var jade         = require ('jade');
} catch (e) {
	// console.log ('jade not available');
}

<span id='task-presenterTask'>/**
</span> * @class task.presenterTask
 * @extends task.task
 *
 * This is a type of task that sends a rendered template as an HTTP response.
 *
 * Implementation specific by definition.
 */
var presenterTask = module.exports = function (config) {
	
	this.init (config);
	
};

util.inherits (presenterTask, task);

var cache = {};

util.extend (presenterTask.prototype, {
<span id='task-presenterTask-method-readTemplate'>	/**
</span>	 * @private
	 */
	readTemplate: function (templateIO, cb) {
		templateIO.readFile (function (err, data) {
			cb.call (this, err, data);
		});
	
	},

<span id='task-presenterTask-method-run'>	/**
</span>	 * @method run
	 * Renders the template from {@link #file} and sends the result
	 * as the content of the {@link #response}.
	 */
	run: function () {

		var self = this;
		
<span id='task-presenterTask-cfg-file'>		/**
</span>		 * @cfg {String} file (required) The template file name.
		 */

<span id='task-presenterTask-cfg-type'>		/**
</span>		 * @cfg {String} type Template type. Tries to guess the type
		 * by the {@link #file} extension.
		 *
		 * Possible values:
		 *
		 * - `jade`, Jade template
		 * - `json`, JSON string
		 * - `asis`, plain text.
		 */

<span id='task-presenterTask-cfg-response'>		/**
</span>		 * @cfg {http.ClientResponse} response (required) The response object.
		 *
		 * This task doesn't populate the {@link #produce}
		 * field of the workflow. Instead, it sends the result via HTTP.
		 */

<span id='task-presenterTask-cfg-contentType'>		/**
</span>		 * @cfg {String} contentType The MIME type of the response content.
		 *
		 * Default values depend on the template {@link #type}.
		 */
		if (!this.type) {
			// guess on file name
			this.type = this.file.match(&quot;.*\\.(.*)$&quot;)[1];
			console.log ('guessed ' + this.type + ' presenter type from filename: ' + this.file);
		}

		if (this.type == 'jade') {
			self.response.setHeader (&quot;Content-Type&quot;, (this.contentType || 'text/html') + '; charset=utf-8');
			var templateIO = project.root.fileIO (this.file);
			// TODO
			//if (cache {this.template}) {
			//	templateIO.stat
			//}
			self.readTemplate (templateIO, function (err, data) {
				if (err) {
					console.error (&quot;can't access &quot; + self.file + &quot; file. create one and define project id&quot;);
					process.kill ();
					return;
				};
				var fn = jade.compile(data, {});
				self.response.end (fn (self.vars));
				self.completed ();

			});

		} else if (this.type == 'json') {
			self.response.setHeader (&quot;Content-Type&quot;, 'application/json; charset=utf-8');
			self.response.end (JSON.stringify (self.vars));
			self.completed ();
		} else  if (this.type == 'asis') {
			self.response.setHeader (&quot;Content-Type&quot;, self.contentType);
			self.response.end (self.vars);
			self.completed ();
		}		
	}
});
</pre>
</body>
</html>
